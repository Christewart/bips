<pre>
  BIP: TBD
  Layer: Consensus (soft fork)
  Title: 64-bit arithmetic in Script
  Author: Chris Stewart <stewart.chris1234@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-?
  Status: Draft
  Type: Standards Track
  Created: ???
  License: BSD-3-Clause
</pre>

==Abstract==

This BIP extends the supported range of numeric operands in Script from -2^<sup>31</sup>+1 to 2^<sup>31</sup>-1, to -2^<sup>63</sup>+1 to 2^<sup>63</sup>-1.
The result range for arithmetic operations is expanded from -2^<sup>63</sup> to 2^<sup>63</sup>-1, to -2^<sup>127</sup> to 2^<sup>127</sup>-1.

This BIP upgrades all existing opcodes<ref>[https://github.com/bitcoin/bitcoin/blob/223fc24c4ebc8dbaecf59ccd36e49193b58d422b/src/script/interpreter.cpp#L944 What are the existing opcodes that interpret stack elements as numbers? OP_ADD, OP_SUB, OP_BOOLAND, OP_BOOLOR, OP_NUMEQUAL, OP_NUMEQUALVERIFY, OP_NUMNOTEQUAL, OP_LESSTHAN, OP_GREATERTHAN, OP_LESSTHANOREQUAL, OP_GREATERTHANOREQUAL, OP_MIN, OP_MAX, OP_1ADD, OP_1SUB, OP_NEGATE, OP_ABS, OP_NOT, OP_0NOTEQUAL]</ref>
that interpret stack elements as numbers to support 64-bit parameters, excluding OP_CHECKLOCKTIMEVERIFY and OP_CHECKSEQUENCEVERIFY.

This BIP retains the encoding format<ref>[https://delvingbitcoin.org/t/64-bit-arithmetic-soft-fork/397/6?u=chris_stewart_5 What is the original Script number encoding format? It’s a minimal-length little-endian with sign-magnitude encoding rather than two’s complement]</ref> and arithmetic semantics<ref>[https://github.com/bitcoin/bitcoin/blob/257fd27e4bb7dfd71e5f9f4dd2db34ff5a7ad957/src/script/script.h#L231 What is Script's current handling of number overflows? Arithmetic results may overflow (and are valid as long as they are not used in a subsequent numeric operation). CScriptNum enforces those semantics by storing results as an int64 and allowing out-of-range values to be returned as a vector of bytes, but throwing an exception if arithmetic is done or the result is interpreted as an integer]</ref> from the original Bitcoin implementation, with enhanced precision.

==Motivation==

Numerous soft fork proposals require support for at least 51 bits of precision in Script to represent satoshi values.
While it is technically possible<ref>[https://rusty.ozlabs.org/2023/10/22/amounts-in-script.html A proof of concept on how to circumvent the precision limits in the original implementation of the Bitcoin protocol]</ref>
to handle such values in the original Script, it is inefficient and error-prone.

===OP_INOUT_AMOUNT===

OP_INOUT_AMOUNT<ref>[https://delvingbitcoin.org/t/op-inout-amount/549/3 OP_INOUT_AMOUNT]</ref> is
part of the OP_TAPLEAFUPDATEVERIFY<ref>[https://gnusha.org/pi/bitcoindev/20210909064138.GA22496@erisian.com.au/ OP_TAPLEAFUPDATEVERIFY]</ref> soft fork proposal.
This opcode pushes two values onto the stack corresponding to the input and output values of the transaction being verified.

Since the value of UTXOs can be up to 51 bits, 64-bit arithmetic operations are required.

===OP_CHECKCONTRACTVERIFY===

OP_CHECKCONTRACTVERIFY<ref>[https://github.com/bitcoin/bips/pull/1793 OP_CHECKCONTRACTVERIFY]</ref> is an
opcode that allows users to create UTXOs carrying a dynamic commitment to a piece of data. When spending
an OP_CHECKCONTRACTVERIFY UTXO, it is necessary to verify that the UTXO's value is properly allocated among the outputs.

Since the value of UTXOs can be up to 51 bits, this opcode could benefit from 64-bit arithmetic operations.

===OP_VAULT===

OP_VAULT<ref>[https://github.com/bitcoin/bips/blob/master/bip-0345.mediawiki OP_VAULT]</ref> is an
opcode designed to enforce a delay period before designated coins may be spent to an arbitrary destination,
with the exception of a prespecified "recovery" path. This opcode requires pushing the output's value onto the stack for validation.<ref>[https://github.com/bitcoin-inquisition/bitcoin/pull/21/files#diff-a0337ffd7259e8c7c9a7786d6dbd420c80abfa1afdb34ebae3261109d9ae3c19R1377 Where OP_VAULT extends CScriptNum's precision to 7 bytes to correctly interpret the revault amount from the stack]</ref>

Since the value of UTXOs can be up to 51 bits, this opcode could benefit from 64-bit arithmetic operations.

===OP_CHECKTEMPLATEVERIFY===

OP_CHECKTEMPLATEVERIFY<ref>[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki#user-content-OP_AMOUNTVERIFY BIP119]</ref> is a proposed covenant opcode.
A future enhancement to OP_CHECKTEMPLATEVERIFY, called OP_AMOUNTVERIFY, could verify the exact amount being spent in the transaction, the amount paid as fees,
or make amounts available in a given output. This could be used to create safer OP_CHECKTEMPLATEVERIFY addresses.

Since the value of UTXOs can be up to 51 bits, this opcode could benefit from 64-bit arithmetic operations.

==Rationale==

===OP_CHECKSEQUENCEVERIFY / OP_CHECKLOCKTIMEVERIFY===

OP_CHECKSEQUENCEVERIFY and OP_CHECKLOCKTIMEVERIFY interpret absolute and relative locktime values based on transaction fields that are limited to 32 bits of precision.
Validation of these values also depends on median-time-past as defined in BIP113.<ref>[https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki BIP113]</ref>
The maximum allowable median-time-past value on the Bitcoin network is 0xfffffffe.<ref>[https://github.com/bitcoin/bitcoin/pull/32229 This PR explicitly tests the maximum median-time-past limit on the Bitcoin network. The results demonstrate that the maximum median-time-past allowed is 0xfffffffe.]</ref>
Extending the numeric range for these opcodes would not yield additional expressiveness, as resulting scripts would remain unsatisfiable.

A potential drawback of not expanding these opcodes to accept 8-byte parameters is the quality of error reporting.
If an operand passed to OP_CLTV or OP_CSV exceeds 5 bytes, Script execution fails with an overflow error.<ref>[https://delvingbitcoin.org/t/overflow-handling-in-script/1549#p-4652-background-3 Overflows propagate a cryptic error message `mandatory-script-verify-flag-failed (unknown error)`, which does not clearly indicate the cause of failure]</ref>
Allowing 64-bit operands could enable clearer and more informative failure modes when locktime validation fails.

===Larger precision than 64 bits===

BIP342<ref>[https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki Since OP_SUCCESSx precedes the size check for the initial stack and push opcodes, an OP_SUCCESSx-derived opcode requiring stack elements larger than 520 bytes could uplift the limit in a soft fork]</ref>
permits the introduction of new opcodes that bypass the 520-byte push size limitation.
This mechanism could theoretically allow for arbitrary-precision numeric operations.
However, the scope of this BIP is intentionally limited to supporting 64 bits of precision, sufficient for expressing native Bitcoin amounts.

==Detailed Specification==

A reference implementation is available at:

https://github.com/Christewart/bitcoin/commits/64bit-arith-cscriptnum

==Deployment==

To be determined.

This proposal could be deployed in conjunction with any of the new opcode proposals in the Motivation section using Tapscript's OP_SUCCESSx semantics.<ref>[https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#cite_note-1 How a new opcode be used to extend existing opcode precision? OP_SUCCESSx may also redefine the behavior of existing opcodes so they could work together with the new opcode. For example, if an OP_SUCCESSx-derived opcode works with 64-bit integers, it may also allow the existing arithmetic opcodes in the same script to do the same.]</ref>

==Backward Compatibility==

As a soft fork, older software will continue to operate without modification.
Non-upgraded nodes, however, will consider all tapscripts that contain an OP_SUCCESSx opcode as ANYONECANSPEND scripts.
They are strongly encouraged to upgrade in order to fully validate the new programs.

==Credits==

This proposal builds on prior work from the Elements Project, with implementations by Sanket Kanjalkar and Andrew Poelstra.

Thanks to Ethan Heilman, AJ Towns for conceptual discussions.

==References==

<references />

==Copyright==

This document is placed in the public domain.